<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta http-equiv="keyword" content="prolog, ai, logic programming, artificial intelligence, expert system, mobile agent, mobile code, Prolog and Java, BinProlog, Jinni, agent library, distributed AI">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; U) [Netscape]">
   <meta name="description" content="innovative software development specializing in Java and Prolog based Internet programming and Intelligent Mobile Agent building tools">
   <title>Prolog interpreter in Java: Jinni - User Guide</title>
</head>
<body>

<center>
<h1>
Kernel Prolog: a Lightweight Prolog-in-Java Interpreter with <i>Fluent</i>
based Built-ins</h1></center>

<center>
<h1>
USER GUIDE</h1></center>

<center>
<h3>
Paul Tarau, November 1999</h3></center>

<h2>
<b>About Kernel Prolog</b></h2>
<i>Kernel Prolog</i> supports a simplified CUT-less and operatorless subset
of ISO Prolog. Its main merit is a redesigned set of built-ins and an axiomatic
reconstruction of Prolog on top of Horn Clauses with first class Fluents.
Kernel Prolog Solvers (first class LD-resolution interpreters), together
with Sources and Sinks provide stateful objects needed to represent the
state of the Solvers as well as for interoperation with the embedding Object
Oriented environment.
<h2>
Getting started</h2>

<h3>
Installation and essential files</h3>
Make sure you uncompress the provided *.zip or *.tar.gz file containing
Kernel Prolog. The toplevel interaction starts with something like
<p><font color="#3333FF">java JinniMain</font>
<p>To run Kernel Prolog from another directory create a small batch file,
<b>kp.bat</b>
containing something like:
<p><font color="#3333FF">java -cp ".;c:/tarau/bp_dist/kprolog" JinniMain
%1 %2 %3 %4 %5 %6 %7 %8 %9</font>
<p>in the case of JDK 1.2 on windows NT. You might need to <i>adapt</i>
this with other versions of Java or on other platforms.
<br>The Visual Kernel Prolog environment is started with gui.bat, calling
something like
<p><font color="#3333FF">java net.sf.kpex.gui.JinniGuiMain ide</font>
<p><i><font size=-1>Quick info - if you want to try out things right away.
Look at the various *.bat files for hints on how to start the various components.</font></i>
<ul>
<li>
<font size=-1><b>kp.bat or go.bat or gui.bat:</b> start flavors of Kernel
Prolog in commandline mode</font></li>
</ul>
The core of Kernel Prolog is in the Java classes inside the subdirectory
<b><a href="tarau/jinni/">tarau/jinni</a></b>.
Look at the Kernel Prolog <a href="docs/index.html">class documentation</a>
in directory <a href="docs">docs</a>. The most important file, allowing
you to configure/fix problems with Kernel Prolog is <i>lib.pro</i> - containing
the definition of most built-ins implemented in Prolog. If you have the
Kernel Prolog sources, the essential files to look at are <i>Init.java,Prog.java,
IO.java</i> and <i>Builtins.java</i> in directory tarau/jinni and the <i>UserBuiltins.java</i>
file showing how to extend Kernel Prolog with new Java operations in the
main Jini directory. The subdirectory tarau.jinniguicontains&nbsp; the
sources and classes of Visual Kernel Prolog - an extension of Kernel Prolog
covering some frequently used Java awt components.
<p>Note: <i>Kernel Prolog has been implemented as a trimmed down derivative
of Jinni ( http://www.binnetcorp.com/Jinni ). Package and file names have
been kept similar to those in Jinni for easier interoperation. However,
both the basic Term tree, IO operations and the interpreter are new and
significantly different from Jinni's. The Jinni GUI has been ported with
minor changes.</i>
<h3>
Using Kernel Prolog in command line mode:</h3>

<p><br><b>Entering a query:</b>
<p>At the prompt "?-" type in a one line Prolog query, as usual, for instance,
something like:
<p><b><i>?- write(hello),nl.</i></b>
<h4>
Consulting a new program:</h4>
<b><i>?-[&lt;myprog>].</i></b>
<p><i>will read in memory the file <b>&lt;myprog>.pro</b> program </i>replacing<i>
similarly named predicates with new ones. It is actually a shorthand for
<b>reconsult/1</b>.
To </i>accumulate<i> clause for similarly named predicates, use <b>consult/1</b>.</i>
<p><b><i>?-co.</i></b>
<p><i>will reconsult </i>again<i> the the last consulted file. If you start
Kernel Prolog with its visual environment, try something like:</i>
<p><b><i>?-ide.</i></b>
<p><i>to lauch an instance of the IDE, or</i>
<p><b><i>?-[vq8],go.</i></b>
<p><i>to run a visual N-Queens program.</i>
<br>&nbsp;
<h3>
Using Kernel Prolog through an applet</h3>
Type <b>appletviewer JinniGUI.htm</b>l . Enter, for instance, in the query
window:
<p><b>append(Xs,Ys,[1,2,3]).</b>
<p>You will see the applet displaying the results. Applets can load files
<i>located
at the site where they originate from</i>. Try
<p><b>?-[q8],queens(8,X)</b>
<p>to consult over the net and run the N-queens program. <i>To launch an
instance of a simple IDE with embedded editor and query processor, type</i>
<p><b><i>?-ide.</i></b>
<br>&nbsp;
<h3>
Building simple Prolog programs with Kernel Prolog</h3>
With the editor of your choice create a text file called simple.pro, with
the following content:
<p><font color="#3333FF">c(X):-a(X),b(X).</font>
<p><font color="#3333FF">a(1).</font>
<br><font color="#3333FF">a(2).</font>
<br><font color="#3333FF">a(3).</font>
<p><font color="#3333FF">b(2).</font>
<br><font color="#3333FF">b(3).</font>
<br><font color="#3333FF">b(4).</font>
<p>In a shell window (DOS command, csh, bash etc.), type <b>java JinniMain</b>
to launch the standalone command line Jinni interpreter, prompting you
with "?- " to enter commands/queries. To load the file type:
<p>?-<font color="#3333FF">[simple].</font>
<p>then try the query:
<p>?-<font color="#3333FF">c(X).</font>
<p><b>Example of reading/writing to files:</b>
<p>Kernel Prolog can read files or URLs and write files in command line
mode. In applet mode Kernel Prolog can only read files described as URLs,
from from the directory it comes from. Try:
<p>?-<font color="#3333FF">clause_file_writer('example.txt',File),fprint_clause(File,example(one)),stop(File).</font>
<p>followed by:
<p>?-<font color="#3333FF">file_clause_reader('example.txt',File),fread(File,X),stop(File),println(X).</font>
<p>Jinni can open a URL over the net, in a way similar to file. Try:
<p>?-<font color="#3333FF">file_char_reader('http://www.binnetcorp.com',Reader),source_list(Reader,Chars),put_codes(Chars),fail.</font>
<p>to print out a HTML file fetched directly from the Web.
<br>&nbsp;
<h1>
LANGUAGE DEFINITION</h1>

<h3>
Syntax</h3>
Unicode based language internationlization is supported by using only the
(wide) <b>char</b> type and appropriate JDK 1.x reader and writer classes.
<br>Kernel Prolog's parser and tokenizer are very small and based on Java's
own built-in parsing/tokenizing libraries (StreamTokenizer). This allows
relying on code already in&nbsp; browsers instead of having to load classes
over the network. In the future, as Kernel Prolog is heading towards plain
Natural Language input through speech recognition software, it's internal
syntax (which might already look too restrictive to Prolog programmers)
will be generated through a preprocessor supporting user defined distfix
operators. As such, kernel Prolog is expected to be able to emulate full
Prolog syntax and more. However, Kernel Prolog's current syntax is <i>restricted
to standard prefix Prolog terms</i> of the form f(T1,..Tn), with the infix
operators ':-' and ',' accepted
<i>only </i>at top level:
<p>Clause ::&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Head :- Body.
<br>Clause ::&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Head.
<br>Head ::&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Term
<br>Body ::&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
CommaSeparatedTerms
<br>CommaSeparatedTerms ::&nbsp;&nbsp;&nbsp;&nbsp; Term {,Term}*
<br>Term ::&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Const | VARIABLES | CompoundTerm
<br>CompoundTerm ::&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
IDENTIFIER(CommaSeperatedTerms)
<br>Const ::&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
IDENTIFIER&nbsp; |&nbsp; INTEGER&nbsp; |&nbsp; REAL
<p>IDENTIFIERs starting with lower case characters and containing <i>only</i>
alphabetical characters do not require quoting, for instance <b>is(X,99)</b>
is a valid term. When IDENTIFIERs start with upper case or contain non-alphabetical
characters they require single quotes, i.e. you should write something
like <b>':-'(a(X),b(X))</b> or <b>'+'(3,4)</b>. Variables start with upper
case characters or "_". Both % one line and /* ... */ multiple line comments
are supported. A way to run under full Prolog programs with trickier operator
syntax is to <i>write them to a file using plain term syntax</i>.
<p>While this syntax looks restrictive, in fact, it is enough for expressing
everything Prolog semantics actually supports. The following table shows
how to handle the differences:
<br>&nbsp;
<br>&nbsp;
<table WIDTH="70%" >
<tr>
<td>Prolog:</td>

<td>Jinni:</td>
</tr>

<tr>
<td>assert((b(X):-a(X),c(X))&nbsp;</td>

<td>assert(':-'(a(X),','(b(X),c(X))))</td>
</tr>

<tr>
<td>X is 3+4</td>

<td>is(X,'+'(3,4))</td>
</tr>
</table>

<p>Some simple definitions like eq(X,X), and if/3 present in Jinni, allow
alternative writings like:
<br>&nbsp;
<table WIDTH="70%" >
<tr>
<td>Prolog:</td>

<td>Jinni:</td>
</tr>

<tr>
<td>(X=1->Y=2;Y=3)</td>

<td>if(eq(X,1),eq(Y,2),eq(Y,3))</td>
</tr>

<tr>
<td>(X=1->true;X=2)</td>

<td>if(eq(X,1),true,eq(X,2))</td>
</tr>
</table>

<h2>
Semantics</h2>
Kernel Prolog can be seen as a collection of Horn Clause Interpreters running
LD-resolution on a default clause database and calling built-in operations.
Through built-in calls, they possess the ability to create other query
first class engines and interoperate with Java through a set of stateful
objects called <b><i>Fluents</i></b>.
<p>Fluents are created with specific constructors, usually named the name
of the type, by converting from other fluents or conventional Prolog data
structures like Terms, Lists or Databases. All Fluents are enabled with
a <b>stop/1</b>&nbsp; operation which releases their resources (most Fluents
also call stop/1 on backtracking to free resources).
<p><b><i>Sources</i></b> are Fluents enabled with an extra <b>get/2</b>
operation. Typical Sources are Horn Clause Engines, File, URL or String
Readers, Fluents built form Prolog lists. <b><i>Sinks</i></b> are fluents
enabled with an extra <b>put/2 and collect/2 </b>operation<b>. </b>Typical
fluents are ClauseWriters or CharWriters targeted to Files,&nbsp; TermCollectors&nbsp;
(implemented as a Java Vectors collecting Prolog terms), StringSinks (implemented
as a Java StringBuffers colecting String representations of Prolog terms).
Prolog Databases are first class citizens implemented as extensions of
Sources which provide <b>add/2, remove/2, collect/2</b> operations.
<p>Fluents are<i> resources</i> which go throuh state transitions as a
result of&nbsp; <b>put/2</b> or <b>get/2 </b>operations. They end their
life cycle in a stopped state when all the resources they hold are freed.
An algebra of Fluent composers provides abstract operations on fluents.
For instance, <b>append_sources/3</b> creates a new Source with a <b>get/2</b>
operation such that when the first Source is stopped, iteration continues
over the elements of the second source.&nbsp;&nbsp; <b>Compose_sources/3</b>
provides a cartesian product style composition, the new<b> get/2</b> operation
returning pairs of elements of the first and second Source. <b>Split_source/3</b>
creates 2 Source objects identical to the Source given as first argument.
It allows writing programs which iterate over a given Source multiple times.
Sources and Sinks are related through a <b>discharge(Source,Sink) </b>operation
which sends all the elements of the Source to the given Sink.
<br>&nbsp;
<h4>
Programming without CUT</h4>
Kernel Prolog does not implement Prolog's CUT. With embedded <b>if/3</b>
constructs,
<b>not/1</b> and using distinct patterns returned as results
from built-ins, to allow
<br>distinct first argument based case analysis, someone can cover easily
most uses of CUT. Using <b>once(Goal) </b>allows restricting your attention
to the first solution of Goal, in a way similar to <b>Goal,! </b>in Prolog.
<center>
<h1>
Some Classic Kernel Prolog built-in predicates</h1></center>
Kernel Prolog's built-in predicates follow the spirit of Prolog while simplifying
when possible and adjusting to its restricted syntax. For their complete
executable specification and typical use cases we refer to the file tarau/jinni/lib.pro
containing the Kernel Prolog system library.
<h3>
Basic Prolog built-ins:</h3>

<ul>
<li>
<b>eq(X,Y): </b>succeeds if X and Y can be unified (as with Prolog's X=Y).</li>

<li>
<b>write(Arg):</b> writes out a term</li>

<li>
<b>nl:</b> writes out a new line</li>

<li>
<b>println(Term): </b>prints out a term on a line - synchronized for multi-threaded
use</li>

<li>
<b>halt: </b>stops Jinni (works in command line mode, but not in applet
mode)</li>

<li>
<b>if(Cond,Then,Else):</b> If <b>Cond </b>succeeds, executes <b>Then</b>
with possible bindings provided by <b>Cond</b>. If <b>Cond</b> fails, the
bindings it produces are undone and <b>Else</b> is executed.</li>

<li>
<b>if_any(Cond,Then,Else):</b> For each alternative <b>Cond </b>thatsucceeds,
executes <b>Then</b> with&nbsp; bindings provided by <b>Cond</b>. If <b>Cond</b>
fails, the bindings it produces are undone and <b>Else</b> is executed.</li>

<li>
<b>not(Goal):</b> succeeds if <b>Goal</b> fails but produces no bindings.
Fails if Goal succeeds.</li>

<li>
<b>and(A,B):</b> executes <b>A</b> and if this succeeds, <b>B</b></li>

<li>
<b>or(A,B):</b> executes A and, after backtracking from A, executes B</li>

<li>
<b>repeat:</b> repeatedly executes the goal following it, until it succeeds</li>

<li>
<b>listing/0, listing/1:</b> lists the predicates in the default database</li>

<li>
<b>put_codes(IntegerList):</b> writes out a list of character codes as
a String</li>

<li>
<b>read(X):</b> reads in a term <b>X</b>. In applet mode this usually happens
from a second editable input field, not the one usually goals are read
in.</li>

<li>
<b>read_clause(Clause,Vars,ClauseWithNamedVars,NamedVars)</b>: reads in
a clause together with its variables in a term '[]'(V1,...Vn) and a copy
of the clause and a copy of its variables instantiated to their original
names</li>

<li>
<b>var(T):</b> succeeds if <b>T </b>is currently a free variable</li>

<li>
<b>nonvar(T):</b> succeeds if T is currently bound to a non-variable term</li>

<li>
<b>integer(T):</b> succeeds if T is instantiated currently to an integer</li>

<li>
<b>float(T):</b> succeeds if T is instantiated currently to an float value</li>

<li>
<b>compound(T):</b> succeeds if T is instantiated currently to a compound
term</li>

<li>
<b>atomic(T):</b> succeeds if T is instantiated currently to an integer,
float or constant object</li>

<li>
<b>numeric(T): </b>succeeds if T is instantiated currently to an integer
of float value</li>

<li>
<b>arg(Nth,Term,Arg):</b> returns the Nth argument of a compound term <b>Term</b>,
in particular its functor for <b>Nth</b>=0.</li>

<li>
<b>functor(F,N,T):</b> <b>T </b>is a new term <b>T</b> based on functor
<b>F</b>
of arity <b>N</b>, i.e. F(V1,...,Vn) with <b>V1,...,Vn</b> fresh variables.</li>

<li>
<b>univ(T,FXs) or '=..'(T,FXs) </b>convert between a term <b>f(X1,...,Xn)</b>
and its "universal"&nbsp; list representation <b>[f,X1,...,Xn]</b>.</li>

<li>
<b>compute(Operation,Operand1,Operand2,Result):</b> raw arithmetic processor.
Used as in: <b>compute('+',2,3,R)</b> with <b>R=5</b> or as in in <b>compute('?',1,2,R)</b>,with
<b>R=-1</b>
(with <b>R</b>=0 if <b>Operand1==Operand2 </b>and <b>R=1</b> if <b>Operand1>Operand2</b>).</li>

<li>
<b>is(Value,Expression): </b>like Prolog's is/2, evaluates its second argument
and unifies the result with the first, for example <b>is(R,'+'(1,'*'(2,3)))</b>
will bind <b>R</b> to <b>7</b>.</li>

<li>
<b>append(Xs,Ys,Zs):</b> succeeds when lists <b>Xs</b> and <b>Ys</b> concatenate
to <b>Zs</b>. Can be used with&nbsp; various patterns, e.g. with known
<b>Zs</b>
and unknown <b>Xs</b>, <b>Ys</b>.</li>

<li>
<b>member(X,Xs):</b> enumerates through backtracking each <b>X </b>such
as <b>X</b> is a member of the list <b>Xs</b></li>

<li>
<b>for(I,Min,Max): </b>enumerates through backtracking each <b>I</b> from
<b>Min</b>
to <b>Max</b></li>

<li>
<b>reconsult('&lt;FILE>.pro'):</b> reconsults a file, i.e. <i>reads</i>
and <i>asserts</i> each clause in the file to the database while <i>overriding</i>
predicate definitions in the database with <i>new</i> definitions read
from the file. To avoid confusion with Perl, the suffix .pro for Jinni
programs is strongly encouraged. The shorthand [&lt;FILE>] results in having
the sufix .pro appended to &lt;FILE> and then in a call to <b>reconsult('&lt;FILE>.pro')</b>.</li>

<li>
<b>consult('&lt;FILE>.pro'):</b> consults a file, i.e. reads and asserts
each clause in the file to the database <i>without destroying</i> other
clauses of the same predicate. This can lead to <i>unwanted multiple occurrences
of clauses</i>, use <b>reconsult/1</b> instead, whenever possible</li>

<li>
<b>co:</b> shorthand for redoing the last <b>reconsult </b>operation</li>

<li>
<b>assert(':-'(Head,Body)) or assert(Head): </b>puts a new clause on the
(remote or local) blackboard, using an <b>out/1</b> operation. If absent,
<b>Body</b>
defaults to <b>true</b></li>

<li>
<b>retract1(Head): </b>remove a matching clause from the (remote or local)
blackboard, using <b>cin/1</b></li>

<li>
<b>clause(Head,Body):</b> backtracks over the clause currently matching
<b>':-'(Head,Body)</b>
on the (remote or local) blackboard</li>

<li>
<b>retract(Head):</b> backtracks over the clauses currently matching <b>':-'(Head,Body)</b>
on the (remote or local) blackboard and tries to applies <b>retract1(Head)</b>
to each. Better to be avoided if multiple threads work in parallel, use
<b>retract1/1</b>
instead</li>

<li>
<b>findall(Pattern,Goal,Answers): builds the list Answers by collecting
copies of all answers of Goal of the form Pattern</b></li>

<li>
<b>length/2: </b>measures the length of a list or generates a new list
of give length</li>

<li>
<b>compare/3:</b> (restricted to arithmetic terms) compares with operation
&lt;,=,> provided as first argument its second and third arguments</li>

<li>
<b>forall(Cases,Goal)</b>: runs Goal for all solutions provided by Cases,
through double negation</li>

<li>
<b>trace/0</b> and <b>notrace/0</b> turn on/off tracing</li>

<li>
<b>why(Goal)</b>: runs Goal and prints out instantiated steps of&nbsp;
its execution</li>

<li>
<b>sleep(Seconds):</b> sleeps without using CPU for a given number of seconds</li>

<li>
<b>sleep_ms(Miliseconds)</b>: sleeps without using CPU for a given number
of miliseconds</li>
</ul>
<i><b>Definitions of these and other built-ins are </b>provided in file
<a href="tarau/jinni/lib.pro">lib.pro.</a></i>
<h3>
Operations on Interpreters (instances of Source Operations)</h3>

<ul>
<li>
<b>answer_source(AnswerPattern,Goal,Interpreter):</b> creates and returns
a new interpreter (a <b>Source</b>)</li>

<li>
<b>get(Interpreter,Answer):</b> asks an engine given as a <b>Interpreter</b>
for a new <b>Answer, </b>which will be of the form <b>the(AnswerPatternInstance)</b>
on success and which will be <b>no</b> on failure as well on any call after
failure occurred</li>

<li>
<b>stop(Interpreter):</b> makes sure the engine is stopped. Only <b>no</b>
answers will be available from the engine in the future.</li>
</ul>

<h3>
File, socket, URL and string based stream operations (based on Source operations)</h3>
Jinni extends ISO Prolog's stream I/O based operations to URLs and strings
- to give a uniform view of all of them as streams.
<h4>
Output operations:</h4>

<ul>
<li>
<b>clause_file_writer(FileName</b>,<b>ClauseWriter)</b> opens a file in
Prolog Clause or Term (structured data) write mode</li>

<li>
<b>char_file_writer(FileName,Writer)</b> opens a file in character code
write mode</li>

<li>
<b>stop(Writer):</b> closes a Writer</li>

<li>
<b>get_stdout(ClauseWriter):</b> returns the standard output stream (as
a ClauseWriter Sink)</li>

<li>
<b>fprint_clause(ClauseWriter,Name):</b> "pretty prints" a term followed
by a dot and a newline to a ClauseWriter</li>

<li>
<b>fwrite(ClauseWriter,Term):</b> prints a term to a stream</li>

<li>
<b>fprint_codes(ClauseWriter,IntegerList):</b> writes out a character code
list</li>

<li>
<b>fprintln(ClauseWriter,Term):</b>&nbsp; writes out a term</li>

<li>
<b>fnl(ClauseWriter): </b>writes out a new line character</li>

<li>
<b>term_string_collector(StringSink):</b> opens a string stream based on
a Java StringBuffer to which terms, lines, characters can be written</li>

<li>
<b>term_collector(TermCollector):</b> opens a Vector to which terms, lines,
characters can be accumulated</li>

<li>
<b>collect(Sink,String):</b> collects the content of a sink to an appropriat
Prolog object</li>
</ul>

<h4>
Input operations:</h4>

<ul>
<li>
<b>file_char_reader(FileorURLName,ClauseReader)</b>: opens a file or URL
for reading character codes</li>

<li>
<b>file_clause_reader(FileorURLName,ClauseReader)</b>: opens a file or
URL for reading character terms and clauses (structured data)</li>

<li>
<b>stop(ClauseReader):</b> closes a <b>ClauseReader</b></li>

<li>
<b>get(ClauseReader,ClauseWithInfo): </b>reads&nbsp; a Clause with related
info (Variables, Variable Names etc.)</li>

<li>
<b>get_stdin(ClauseReader):</b> returns the standard input stream</li>

<li>
<b>fread(ClauseReader,Clause):</b> reads a Clause from a ClauseReader</li>

<li>
<b>fread(ClauseReader,Clause,Vars,ClauseWithNamedVars,VarNames): </b>reads
a clause as well as the variables and their names in two terms of the form
<b>answer(V1,...Vk)</b>
and <b>answer(N1,...,Nk)</b></li>

<li>
<b>similar read/N operations are provided with the first argument replaced
with (implicit) standard input</b></li>

<br>&nbsp;</ul>

<h3>
Database operations</h3>

<ul>
<li>
<b>assert(Clause):</b> puts Clause to the Database</li>

<li>
<b>retract1(Clause): removes and returns the first matching clause</b></li>

<li>
<b>all(X,Xs):</b> returns the list <b>Xs </b>of terms currently on the
blackboard&nbsp; matching <b>X </b>(unfiable with X)</li>

<li>
<b>cin(X,R):</b> removes and returns a term <b>R</b> currently on the blackboard&nbsp;
matching <b>X</b> and fails if no such term exists.</li>

<li>
<b>rd(X)</b>: tests if a matching term unifiable with X is on the blackboard,&nbsp;
and fails otherwise</li>
</ul>

<center>
<h2>
</h2></center>

<center>
<h1>
Fluent Based Built-ins and Derived Operations</h1></center>

<h3>
Fluent Constructors</h3>
Fluents are created with specific constructors, usually by converting from
other Fluents or conventional Prolog data structures like Terms, Lists
or Databases. 2. All Fluents are enabled with a stop/1 operation which
releases their resources (most Fluents also call stop/1 on backtracking,
through their internal undo operation).
<p>In our Java based reference implementation, the Fluent class looks as
follows:
<p><font color="#3333FF">class Fluent extends SystemObject {</font>
<br><font color="#3333FF">&nbsp; Fluent(Prog p) {</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; trailMe(p);</font>
<br><font color="#3333FF">&nbsp; }</font>
<p><font color="#3333FF">&nbsp; // add the fluent to the parent Interpreter's
Trail</font>
<br><font color="#3333FF">&nbsp; protected void trailMe(Prog p) {</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; if(null!=p) p.getTrail().push(this);</font>
<br><font color="#3333FF">&nbsp; }</font>
<p><font color="#3333FF">&nbsp; // usable (through overriding) to release
resources</font>
<br><font color="#3333FF">&nbsp; // and/or stop ongoing computations</font>
<br><font color="#3333FF">&nbsp; public void stop() {</font>
<br><font color="#3333FF">&nbsp; }</font>
<p><font color="#3333FF">&nbsp; // release resources on backtracking, if
needed</font>
<br><font color="#3333FF">&nbsp; protected void undo() {</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; stop();</font>
<br><font color="#3333FF">&nbsp; }</font>
<br><font color="#3333FF">}</font>
<p>Sources are Fluents enabled with an extra <b>get/2 </b>operation. Typical
Sources are Horn Clause Interpreters, File, URL or String Readers, Fluents
built form Prolog lists, Fluents iterating over data structures like Vectors
or Hashtables or Queues in the underlying implementation language.
<p>Note that the constructor <b>Fluent(Prog p)</b> does a trailing operation
on the caller program p's Trail, and provides and undo operation to be
called by <b>p</b> on backtracking, to release resources through the Fluent's
stop method.
<p>In our Java based reference implementation the Source abstract class
looks as follows:
<p><font color="#3333FF">abstract class Source extends Fluent {</font>
<br><font color="#3333FF">&nbsp; Source(Prog p) {</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; super(p);</font>
<br><font color="#3333FF">&nbsp; }</font><font color="#3333FF"></font>
<p><font color="#3333FF">&nbsp; abstract public Term get();</font>
<br><font color="#3333FF">}</font>
<p><b>Sinks</b> are fluents enabled with an extra <b>put/2</b> and <b>collect/2</b>
operation. Typical Sinks are ClauseWriters or CharWriters targeted to TermCollectors
(implemented as a Java Vectors collecting Prolog terms), StringSinks (implemented
as a Java StringBuffers collecting String representations of Prolog terms),
Files.
<p>In our Java based reference implementation the Sink abstract class looks
as follows:
<p><font color="#3366FF">abstract class Sink extends Fluent {</font><font color="#3366FF"></font>
<p><font color="#3366FF">&nbsp; Sink(Prog p) {</font>
<br><font color="#3366FF">&nbsp;&nbsp;&nbsp; super(p);</font>
<br><font color="#3366FF">&nbsp; }</font><font color="#3366FF"></font>
<p><font color="#3366FF">&nbsp; // sends T to the Sink for tasks as</font>
<br><font color="#3366FF">&nbsp; // accumulation or printing</font>
<br><font color="#3366FF">&nbsp; abstract public int put(Term T);</font><font color="#3366FF"></font>
<p><font color="#3366FF">&nbsp; // return data previously sent to the Sink</font>
<br><font color="#3366FF">&nbsp; // (if collection ability is present)</font>
<br><font color="#3366FF">&nbsp; public Term collect() {</font>
<br><font color="#3366FF">&nbsp;&nbsp;&nbsp; return null;</font>
<br><font color="#3366FF">&nbsp; }</font>
<br><font color="#3366FF">}</font>
<p>Not surprisingly, even Prolog databases are first class citizens implemented
as extensions of Sources which provide <b>add/2</b>, <b>remove/2</b>, <b>collect/2</b>
operations.
<p>Fluents can be seen as resources which go through state transitions
as a result of<b> put/2</b>, <b>get/2</b> and <b>stop/</b>1 operations.
They end their life cycle in a stopped state when all the data structures
and/or threads they hold are freed.
<br>&nbsp;
<h3>
Fluent Composers</h3>
Fluent composers provide abstract operations on Fluents. They are usually
implemented with lazy semantics.
<p>For instance,<b> append_sources/3</b> creates a new Source with a get/2
operation such that when the first Source is stopped, iteration continues
over the elements of the second Source.
<p><b>Compose_sources/3</b> provides a cartesian product style composition,
the new <b>get/2</b> operation returning pairs of elements of the first
and second Source. <b>Reverse_source/2</b> builds a new Source such that
its <b>get/2</b> method returns its elements in reverse order.
<p><b>Split_source/3</b> creates two Source objects identical to the Source
given as first argument. It allows writing programs which iterate over
a given Source multiple times. Sources and Sinks are related through a
discharge(Source,Sink) operation which sends all the elements of the Source
to the given Sink.
<h3>
Fluent Modifiers</h3>
Fluent modifiers allow dynamically changing some attributes of a give Fluent.
For instance <b>set_persistent(Fluent,YesNo)</b> is used to make a Fluent
survive failure, by disabling its <b>undo</b> method, which, by default,
applies the Fluent's <b>stop</b> method on backtracking.
<h3>
Interpreters as Answer Sources</h3>
Let us put to work in a more specific way the view of <i>Interpreters as
Fluents</i>. All we have to do, is provide is a Fluent constructor, creating
an <i>Answer Source</i> from an Answer Pattern and a Goal given to an Interpreter.
As a result, we will cover negation, limited pruning through
<b>once/1</b>,
<b>if-then-else/3</b>, <b>findall/3</b>, <b>var/1</b>, and, beyond standard
Prolog, forms of lazy, on-demand generation of sets of solutions, as well
as a uniform set of built-ins for manipulation of first class Prolog databases
and external objects like Files or URLs.
<p><b>Answer Sources</b> can be seen as generalized iterators, allowing
a given program to control answer production in another. Each Answer Source
works as a separate Horn Clause LD-resolution interpreter.
<p>The <b>Answer Source</b> constructor initializes a new interpreter.
<pre><font size=-1>answer_source(AnswerPattern,Goal,AnswerSource)</font></pre>
creates a new Horn Clause solver, uniquely identified by <b>AnswerSource</b>
(a Source Fluent), which shares code with the currently running program
and is initialized with resolvent <b>Goal</b>. <b>AnswerPattern</b> is
a term, usually a list of variables occurring in <b>Goal</b>.
<p>The <b>get/2</b> operation (provided by all <b>Sources</b>) is used
to retrieve successive answers generated by an Answer Source, on demand.
<pre><font size=-1>get(AnswerSource,AnswerInstance)</font></pre>
tries to harvest the answer computed starting from <b>Goal</b>, as a instance
of <b>AnswerPattern</b>. If an answer is found it is returned as <b>the(AnswerInstance)</b>,
otherwise <b>no</b> is returned. Note that once <b>no</b> has been returned,
all subsequent <b>get/2</b> on the same <b>AnswerSource</b> will return
<b>no</b>.
Bindings are not propagated to the original <b>Goal</b> or <b>AnswerPattern</b>
when <b>get</b> retrieves an answer, i.e. <b>AnswerInstance</b> is obtained
by first standardizing apart (renaming) the variables in <b>Goal</b> and
<b>AnswerPattern</b>,
and then backtracking over its alternative answers in a separate Prolog
interpreter. Therefore, backtracking in the caller interpreter does not
interfere with the new Answer Source's iteration over answers. Note however
that backtracking over the Answer Source's creation point as such makes
it unreachable and therefore subject to garbage collection.
<p>Finally, an Answer Source is stopped with the <b>stop/1</b> operation
implemented by all <b>Sources</b>.
<pre><font size=-1>stop(AnswerSource)</font></pre>
The <b>stop/1</b> operation is called automatically when no more answers
can be produced as well as through the Fluent's <b>undo</b> operation on
backtracking.
<h3>
&nbsp;Source level extensions through new definitions</h3>
To give a glimpse to the expressiveness of the resulting language, we will
know introduce, through definitions in Kernel Prolog, a number of predicates
known as `impossible to emulate' in Horn Clause Prolog (except by significantly
lowering the level of abstraction and implementing something close to a
Turing machine).
<h4>
Negation and <tt>once/1</tt></h4>
These constructs are implemented simply by discarding all but the first
solution produced by a Solver.
<br><font size=-1>% returns the(X) or no as first solution of G</font>
<br><font size=-1>first_solution(X,G,Answer):-</font>
<br><font size=-1>&nbsp; answer_source(X,G,Solver),</font>
<br><font size=-1>&nbsp; get(Solver,R),</font>
<br><font size=-1>&nbsp; stop(Solver),</font>
<br><font size=-1>&nbsp; eq(Answer,R).</font>
<p><font size=-1>% succeeds by binding G to its first solution or fails</font>
<br><font size=-1>once(G):-first_solution(G,G,the(G)).</font>
<p><font size=-1>% succeeds without binding G, if G fails</font>
<br><font size=-1>not(G):-first_solution(_,G,no).</font>
<br>&nbsp;
<h4>
Reflective Meta-Interpreters</h4>
The simplest meta-interpreter <b>metacall/1</b> just reflects backtracking
through <b>element_of/2</b> over deterministic Answer Source operations.
<pre><font size=-1>metacall(Goal):-
&nbsp; answer_source(Goal,Goal,E),
&nbsp; element_of(E,Goal).
&nbsp;&nbsp;
element_of(I,X):-get(I,the(A)),select_from(I,A,X).

select_from(_,A,A).
select_from(I,_,X):-element_of(I,X).</font></pre>
We can see <b>metacall/1</b> as an operation which fuses two orthogonal
language features provided by Answer Sources:
<i>computing an answer of
a Goal</i>, and <i>advancing to the next answer</i>, through the source
level operations <b>element_of/2</b> and
<b>select_from/3</b> which 'borrow'
the ability to backtrack from the underlying interpreter.
<p><i>Note that <b>element_of/2</b> works generically on <b>Sources</b>
and is therefore reusable, for instance, to backtrack over the character
codes of a file or a URL</i>.
<p>We can now build a meta-interpreter which implements the transitive
closure of the unfolding operation (provided as the get/2 operation of
an Unfolder Source in the underlying implementation language), combined
with backtracking trough <b>element_of/2</b>.
<pre><font size=-1>unfold_solve(Goal):-
&nbsp; unfold(':-'(Goal,Goal),':-'(Goal,true)).

unfold(Clause,Clause).
unfold(Clause,Answer):-
&nbsp; unfolder_source(Clause,Unfolder),
&nbsp; element_of(Unfolder,NewClause),
&nbsp; unfold(NewClause,Answer).</font></pre>

<h4>
If-then-else</h4>
Once we have first solution and metacall operations, emulating if-then-else
is easy.
<pre><font size=-1>% if Cond succeeds executes Then otherwise Else
if(Cond,Then,Else):-
&nbsp; first_solution(successful(Cond,Then),Cond,R),
&nbsp; select_then_else(R,Cond,Then,Else).

select_then_else(the(successful(Cond,Then)),Cond,Then,_):-Then.
select_then_else(no,_,_,Else):-Else.</font></pre>

<h4>
All-solution predicates</h4>
All-solution predicates like findall/3 can be obtained simply as:
<p><font size=-1>findall(X,G,Xs):-</font>
<br><font size=-1>&nbsp;&nbsp; answer_source(X,G,Solver),</font>
<br><font size=-1>&nbsp;&nbsp; source_list(Solver,Xs).</font>
<p>We also provide a direct implementation of <b>Database Fluents</b>,
which reflect to object level the interpreter's own handling of the Prolog
database. As an additional benefit, multiple databases are provided. See
predicates starting with <b>db_</b> for operations on databse fluents,
in file lib.pro.
<h3>
Lists and Terms as Source Fluents</h3>
Sequential Prolog data structures are mapped to Fluents naturally. For
instance, <b>list_source/2</b> creates a new Fluent based on a List, such
that its <b>get/2</b> operation will return one element of the list at
a time. Similarly <b>term_source/2</b> creates a Fluen from an N-argument
compound term, such that its <b>get/2</b> method will return firs its function
symbol then each argument. These built-ins are usable to emulate conventional
Prolog operations like <b>univ/2</b> (also known as <tt>=..</tt>) quite
easily:
<pre><font size=-1>univ(T,FXs):-if(var(T),list_to_fun(FXs,T),fun_to_list(T,FXs)).

list_to_fun(FXs,T):-list_source(FXs,I),source_term(I,T).
fun_to_list(T,FXs):-term_source(T,I),source_list(I,FXs).</font></pre>
As they can be converted easily to/from Prolog data-structures, Fluents
are usable as canonical representation for data objects as well as for
computational processes (like in the case of <b>answer_sources</b>). Note
that they also allow fast iteration using loops over efficient native data
structures in the implementation language instead of recursion in the object
language. Clearly, interfacing with external objects is also made simpler
by this fact.
<br>&nbsp;
<h3>
Arithmetics</h3>

<h4>
Arithmetics through built-in and user defined functions</h4>
Note that one can assume, at an abstract level, that arithmetics is part
of Kernel Prolog through the usual extension of Horn Clauses with successor
arithmetics.
<p>Kernel Prolog provides a unique built-in for handling arithmetic functions,
<pre><font size=-1>&nbsp; compute(Operation,Arg1,Arg2,Result)</font></pre>
An enhanced <b>is/2</b> evaluator, supporting execution of arbitrary user
defined functions of N arguments provided as N+1 argument Prolog relations,
is implemented at source level.
<h4>
Lazy Arithmetics with Fluents</h4>
Arithmetic operations producing sequences like random number generators,
primes, arithmetic or geometric series etc. can be implemented efficiently
in the underlying language and provided in Kernel Prolog as fluents. Our
reference implementation provides a generic
<pre><font size=-1>&nbsp; integer_source(MaxFuel,A,X,B).</font></pre>
built-in operation allowing iterated computation of X&lt;-A*X+B at most
MaxFuel times (or an infinite sequence if MaxFuel = 0). Building specialized
arithmetic operations on top of this is quite easy:
<p><tt><font size=-1>% works with From =&lt; To as well as with To =&lt;
From</font></tt>
<br><tt><font size=-1>counter(From,To,Counter):-</font></tt>
<br><tt><font size=-1>&nbsp; compute('-',To,From,Dif),</font></tt>
<br><tt><font size=-1>&nbsp; compute('?',To,From,Sign),</font></tt>
<br><tt><font size=-1>&nbsp; compute('*',Dif,Sign,N),</font></tt>
<br><tt><font size=-1>&nbsp; compute('+',N,1,Steps),</font></tt>
<br><tt><font size=-1>&nbsp; integer_source(Steps,1,From,Sign,Counter).</font></tt><tt><font size=-1></font></tt>
<p><tt><font size=-1>for(I,From,To):-</font></tt>
<br><tt><font size=-1>&nbsp; counter(From,To,Counter),</font></tt>
<br><tt><font size=-1>&nbsp; element_of(Counter,I).</font></tt><tt><font size=-1></font></tt>
<p><tt><font size=-1>ints(From,To,Ns):-</font></tt>
<br><tt><font size=-1>&nbsp; counter(From,To,Counter),</font></tt>
<br><tt><font size=-1>&nbsp; source_list(Counter,Ns).</font></tt><tt><font size=-1></font></tt>
<p><tt><font size=-1>ints(Max,Ns):-ints(1,Max,Ns).</font></tt>
<br><tt><font size=-1></font></tt>&nbsp;
<h3>
Memoing Fluents</h3>
Most Fluents are designed to be usable only once, by default, and release
all resources held (automatically on backtracking or under programmer's
control when their <b>stop</b> operation is invoked). While Fluent operations
like
<b>split_fluent/3</b> can be used to duplicate most Source Fluents,
the following alternative provides a more efficient alternative.
<p>A <b>Memoing Fluent</b> is built easily on top of a Source Fluent by
accumulating values in a List or dynamic array. A Memoing Fluent can be
shared between multiple consumers which want to avoid recomputation of
a given value.
<h4>
Fluent based Lazy Lists</h4>
Lazy Lists can be seen as an instance of <b>Memoing Fluents</b>: they accumulate
successive values of a Source Fluent in a (reusable) list. The simple Lazy
List abstraction in our reference implementation works as follows:
<pre><font size=-1>&nbsp; source_lazy_list(Source, LazyList)</font></pre>
creates a new LazyList object form a Source object:
<pre><font size=-1>&nbsp; lazy_head(LazyList, LazyHead)</font></pre>
extracts the current head element of the list. Iteration over the list
is provided by
<pre><font size=-1>&nbsp; lazy_tail(LazyList, LazyTail)</font></pre>
which returns LazyTail, a new lazy list encapsulating the next stage of
the Source fluent.
<p>While complete automation of lazy lists through a form of attributed
variable construct is possible, we have chosen a simpler implementation
scenario based on the previously described operations, mainly because overriding
unification with execution of an arbitrary procedure would introduce potential
<i>non-termination</i>
- something which would break the very idea of keeping the execution mechanism
as close as possible to basic Horn Clause resolution, as available in classic
Prolog.
<p>Based on these operations, a lazy <b>findall/3</b> is simply:
<pre><font size=-1>% creates lazy list form an answer source
lazy_findall(X,G,LazyList):-
&nbsp; answer_source(X,G,S),
&nbsp; source_lazy_list(S,LazyList).</font></pre>
In fact, the behavior of the lazy list encapsulating <b>lazy_findall's</b>
advancement on alternative solutions produced by an Answer Source, is indistinguishable
from a lazy list constructed from an ordinary <b>list_source</b>:
<pre><font size=-1>% creates a lazy list from a lazy_list(List,LazyList):-
&nbsp; list_source(List,S),
&nbsp; source_lazy_list(S,LazyList).</font></pre>
The following operations will produce a lazily growing reusable list, to
be explored with <b>lazy_element_of/2</b> in a way similar ordinary lists
are explored with <b>member/2</b>.
<pre><font size=-1>% explores a lazy list in a way compatible with backtracking
% allows multiple 'consumers' to access the list, end ensures that
% the lazy list advances progressively and consistently

lazy_element_of(XXs,X):-
&nbsp; lazy_decons(XXs,A,Xs),
&nbsp; lazy_select_from(Xs,A,X).

% backtracks over the lazy list
lazy_select_from(_,A,A).
lazy_select_from(XXs,_,X):-lazy_element_of(XXs,X).

% returns a head/tail pair of a non-empty lazy list
lazy_decons(XXs,X,Xs):-
&nbsp; neq(XXs,[]),
&nbsp; lazy_head(XXs,X),
&nbsp; lazy_tail(XXs,Xs).</font></pre>
A minor change on Prolog's chronological backtracking is needed however:
only the creation point of the lazy list is subject to trailing, and the
complete lazy list is discarded at once. This is achieved easily in our
reference implementation by giving to each lazy list its own (dynamically
growing) trail, and by providing an <b>undo</b> operation which rewinds
the trail completely when backtracking passes the lazy list object's creation
point.
<h3>
Multi Variables and Fluent based DCGs</h3>
Multi-Variables are special Fluents which accumulate multiple values on
an internal stack. As the stack is popped on backtracking multi-variables
return to their previous values, therefore providing a form of backrackable
destructive assignment. A new Multi-Variable is built with <b>def(MultiVar,InitialValue)</b>,
it is uodated with <b>set(MultiVar,NewValue)</b> and its current value
is retrived with <b>val(MultiVar,Value))</b>.
<p>Among its applications, multi-stream DCGs, following BinPtrolog's Assumption
Grammars implementation model, which does not require a DCG preprocessor,
but uses backrackable destructive assignment instead, for advancing the
state of a given DCG stream.
<pre><font size=-1>dcg_def(MultiVar,Xs):-def(MultiVar,Xs).
dcg_val(MultiVar,Xs):-val(MultiVar,Xs).
dcg_connect(MultiVar,X):-val(MultiVar,[X|Xs]),set(MultiVar,Xs).</font></pre>
The resulting implementation initializes an input list with <b>dcg_def/2</b>,
retrieves its current value with <b>dcg_val/2</b> and advances with the
<b>dcg_connect/2</b>
relation, which consumes/generates a terminal symbol each time is called.
<h3>
<i>We refer to the file tarau/jinni/lib.pro for the precise semantics of
Jinni built-ins and some other, less frequently used built-ins available
in Jinni.</i></h3>

<h1>
Calling Kernel Prolog from Java</h1>

<p><br>A simple String to String function askJinni can be used to call
Jinni from Java. Make sure you initialize Jinni first with something like
<b>Init.run(null).
</b>The
string <b>s</b> returned by something like <b>String s=Init.askJinni("eq(X,1)");
</b>can
be processed with Java String functions quite easily to extract the field
containing the relevant answer. The following methods, from class Init.java,
provide Term to Term functions for more efficient&nbsp; Java to Jinni calls,
not going through String representations.
<p>&nbsp; /**
<br>&nbsp;&nbsp;&nbsp; Asks a quert\y to return Answer such tha Goal succeeds
and returns the
<br>&nbsp;&nbsp;&nbsp; first solution of the form "the(Answer)" or the
constant&nbsp; "no" if no solution exists
<br>&nbsp; */
<br>&nbsp; public static Term askJinni(Term Answer,Term Goal) {
<br>&nbsp;&nbsp;&nbsp; return Prog.fg(Answer,Goal);
<br>&nbsp; }
<p>&nbsp; /**
<br>&nbsp;&nbsp;&nbsp; Asks Jinni a query Goal and returns the
<br>&nbsp;&nbsp;&nbsp; first solution of the form "the(Answer)" , where
<br>&nbsp;&nbsp;&nbsp; Answer is an instance of Goal or the constant
<br>&nbsp;&nbsp;&nbsp; "no" if no solution exists
<br>&nbsp; */
<br>&nbsp; public static Term askJinni(Term Goal) {
<br>&nbsp;&nbsp;&nbsp; return askJinni(Goal,Goal);
<br>&nbsp; }
<p>Look examples of their use&nbsp; in some Java to Jinni calls in the
GUI subdirectory, implementing Visual Jinni.
<br>&nbsp;
<h1>
Calling Java from Kernel Prolog</h1>
Calling Java from Kernel Prolog happens through instances of FunBuiltin
and ConstBuiltin. Each builtin has to be <i>registered</i>, allowing Kernel
Prolog to
<br>dynamically integrate it into its runtime system.
<p>An example package in tarau/jinnigui is provided. Adding builtins is
self explanatory once the programmer becomes aware of the following issues:
<ul>
<li>
The arity and Prolog name of the builtin is defined with <b>super(name,arity)</b>
if >0. In the case of arity 0, use instances of ConstBuiltin. There are
no limits on arity.</li>

<li>
The arguments passed from&nbsp; to Java are collected with <b>getArg(I),</b>
with I in 0..arity-1, then casted to the appropriate</li>

<li>
Java types. Success is returned as 1, failure as 0, error as -1 in the
<b>exec()</b>&nbsp;
method of the builtin.</li>

<li>
As many output arguments as needed are returned with <b>putArg(I) </b>which
triggers unification on the Prolog side (for instance to bind a free variable
to the returned value) possibly resulting in failure</li>

<li>
<b>getArg(I) </b>can also used to explore arguments of compound data, in
particular lists</li>

<li>
Converting a list to a functor and back - with <b>univ/2</b> then accessing
arguments one by one with getArg(I) is probably the best way to exchange
lists with Jinni</li>
</ul>
Take a look at the Java files in directory <a href="../JAVA/tarau/jinnigui">tarau/jinnigui</a>
for more examples of built-ins, and read the next section for their description.
<br>&nbsp;
<center>
<h1>
Visual Kernel Prolog</h1></center>
Visual Kernel Prolog is a GUI library built by extending Jinni with user
defined built-ins and Java to Prolog calls associated to Java events. This
enables Prolog&nbsp; to work as a high-level Visual scripting language.
For instance, the following script (part of the script library <a href="../JAVA/tarau/jinnigui/gui_lib.pro">gui_lib.pro</a>)
shows how to customize a simple editor component, running in its own frame
(window).
<p><font color="#3333FF">% creates a default editor</font>
<br><font color="#3333FF">edit:-edit(50,50).</font>
<p><font color="#3333FF">% creates editor component in new frame positioned
at WhereX, WhereY</font>
<br><font color="#3333FF">edit(WhereX,WhereY):-</font>
<br><font color="#3333FF">&nbsp; new_frame('Jinni Editor Component',1,1,F),</font>
<br><font color="#3333FF">&nbsp; move(F,WhereX,WhereY),</font>
<br><font color="#3333FF">&nbsp; edit_in(F),</font>
<br><font color="#3333FF">&nbsp; show(F).</font>
<p>Let us walk through a complet example, defining a Jinni button with
an associated action defined as Prolog code. First, we create a subclass
of Button, customized for our needs, called
<b>JinniButton</b>.
<p><font color="#3333FF">/**</font>
<br><font color="#3333FF">&nbsp;&nbsp; Button with attached Jinni action.</font>
<br><font color="#3333FF">&nbsp;&nbsp; Runs action on new thread, when
Button pushed.</font>
<br><font color="#3333FF">*/</font>
<br><font color="#3333FF">class JinniButton extends Button implements Runnable
{</font>
<br><font color="#3333FF">&nbsp; JinniButton(String name,Term action) {</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; super(name);</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; this.name=name;</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; this.action=action; // copy()
called in corresponding builtin</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; prog=null;</font>
<br><font color="#3333FF">&nbsp; }</font>
<p><font color="#3333FF">&nbsp; private String name;</font>
<br><font color="#3333FF">&nbsp; private Term action;</font>
<br><font color="#3333FF">&nbsp; private Prog prog;</font>
<p><font color="#3333FF">&nbsp; /**</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp; Passes action to Jinni
when Button is pushed</font>
<br><font color="#3333FF">&nbsp; */</font>
<br><font color="#3333FF">&nbsp; public void run() {</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; if(prog!=null) prog.stop();</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; prog=Prog.bg(action); //runs
goal</font>
<br><font color="#3333FF">&nbsp; }</font>
<br><font color="#3333FF">}</font>
<p><font color="#330033">Note</font><font color="#000000"> that JinniButton
implements Runnable. It will trigger an action on its own Jinni thread
- started with <b>Prog.bg(action), </b></font>where action is a fresh copy
of a Jinni goal, passed to the Button by its constructor.
<p><font color="#3333FF">/**</font>
<br><font color="#3333FF">&nbsp; new_button(JinniContainer,Name,Action,Button):</font>
<br><font color="#3333FF">&nbsp; creates a Button with label Name</font>
<br><font color="#3333FF">&nbsp; and attaches to it an action Action</font>
<br><font color="#3333FF">*/</font>
<br><font color="#3333FF">class new_button extends UserFunBuiltin {</font>
<br><font color="#3333FF">&nbsp; public new_button() {super(4);}</font>
<p><font color="#3333FF">&nbsp; // arg 0=container, arg 1=name, arg 2=action,
arg 3=button</font>
<br><font color="#3333FF">&nbsp; public int exec(Prog p) {</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; JinniContainer C =(JinniContainer)(((JavaObject)getArg(0)).toObject());</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; String name=getArg(1).toUnquoted();</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; JinniButton JB=new JinniButton(name,getArg(2).copy());</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; C.add_it(JB);</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp; return putArg(3,new JavaObject(JB),p);</font>
<br><font color="#3333FF">&nbsp; }</font>
<br><font color="#3333FF">}</font>
<p>Note&nbsp; that a JavaObject is returned - this can be later used as
an argument - for instance in can be colored, resized etc. The event handling
mechanism of Jinni, while compatible with Java 1.02, is somewhat similar
with later Java event models - in fact,&nbsp; it is, arguably, more generic.
It uses the following simple trick: when the event target is an instance
of Runnable, our event handling mechanism just calls its <b>run</b> method.
This allows defining only one action handler in the top level window (frame),
which will dispatch events in a generic way, to various Runnable components.
The <a href="../JAVA/tarau/jinnigui/GuiBuiltins.java">code</a> is as follows:
<p><font color="#3333FF">// action attached to a frame (top level window)</font>
<p><font color="#3333FF">&nbsp;public boolean action(Event evt, Object
arg) {</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(evt.target
instanceof Runnable) {</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new
Thread((Runnable)evt.target).start();</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IO.println("UNEXPECTED&nbsp;
TARGET: "+evt.target);</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
false;</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font>
<br><font color="#3333FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;</font>
<br><font color="#3333FF">&nbsp;&nbsp; }</font>
<br>&nbsp;
<p>For more information, read the White Paper on the Design and Reference
Implementation of Kernel Prolog in <a href="fluents.html">HTML</a> or <a href="fluents.ps">PostScript</a>
form.
<p>Copyright (c) BinNet Corp 1999, and Paul Tarau, 1999
<br>&nbsp;
</body>
</html>
